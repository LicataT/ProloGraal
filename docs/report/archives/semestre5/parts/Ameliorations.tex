\documentclass[../report.tex]{subfiles}
\begin{document}
\section{Améliorations possibles}
Cette section donne quelques améliorations possibles du projet, en discutant de la faisabilité technique et de l'implémentation de chacune.
\subsection{Optimisations et intégration plus forte à Truffle}
Le moteur est actuellement très peu optimisé (pour ne pas dire pas optimisé du tout...). Il y a beaucoup d'améliorations possibles à beaucoup d'endroits du projet, mais le principal serait d'améliorer le processus de résolution.
\subsubsection{Améliorations du noeud de résolution}
Dans sa version actuelle, chaque noeud de l'arbre de preuve crée deux copies de chaque clause potentiellement unifiable avec le but courant. En parlant de celui-ci, son état est également sauvegardé (ce qui produit des ajouts de l'état des variables à des piles) et restoré une fois pour chaque clause potentielle, puis une fois pour chaque clause unifiable... Les clauses sont également unifiées au but courant deux fois, une fois pour les filtrer, puis une fois pour mettre l'état correct des variables.

Il est évidemment possible de faire mieux. Une piste serait par exemple de garder l'état du but courant en mémoire pour chaque clause, plutôt que d'oublier son état et de le restaurer à l'aide d'une nouvelle unification plus tard.
\subsubsection{Amélioration du processus de résolution}
De manière plus générale, le processus de résolution s'appuie actuellement sur la pile d'appels, ce qui limite les possibilités de récursion à la taille de ladite pile. On pourrait simuler le comportement à l'aide d'une boucle et d'une pile externe pour enlever cette limite.

Mais il faudrait d'abord améliorer l'intégration avec Truffle, et vérifier les performances, car Truffle est capable de faire de la \textit{Tail Call Optimization}\footnote{\href{https://cesquivias.github.io/blog/2015/01/15/writing-a-language-in-truffle-part-4-adding-features-the-truffle-way/\#tail-call-optimization-in-truffle}{https://cesquivias.github.io/blog/2015/01/15/writing-a-language-in-truffle-part-4-adding-features-the-truffle-way/\#tail-call-optimization-in-truffle}} et est donc capable de potentiellement enlever la limitation de la pile d'appels sans que l'on doive nous même faire le changement.
\subsubsection{Intégration plus forte avec Truffle}
Le projet s'appuie finalement très peu sur les fonctionnalités de Truffle. Très peu de changements seraient requis pour s'en passer complètement. Cela veut également dire que l'on ne profite pas du tout des apports en vitesse promis par Truffle.

Une piste d'utilisation de Truffle est dans le mécanisme de spécialisations : on fournit plusieurs versions d'une même fonction avec des arguments différents, et Truffle se charge d'appeler la bonne (un peu comme la surcharge de méthodes, mais avec moins de coût à l'exécution grâce à la compilation partielle). Cette approche est fondamentalement différente de celle actuellement utilisée. L'implémentation actuelle est sous cette forme : une classe représentant un certain composant de Prolog contient les différentes actions possibles pour ce composant, par exemple l'unification. L'approche Truffle serait la suivante : une classe représentant une action, par exemple l'unification, et plusieurs méthodes représentant la réalisation de cette opération pour les différents types.
\subsection{Support de l'interopérabilité avec Truffle}
Truffle propose une API pour faciliter l'interopérabilité entre différents langages de programmation. Cette API se base sur le principe de messages, indiquant les fonctionnalités d'un certain objet. Par exemple, un objet peut avoir le message \texttt{executable} pour indiquer qu'il peut être exécuté (comme une méthode, ou un prédicat par exemple dans notre cas).

La première étape pour rendre notre langage interopérable serait d'étudier la partie \textit{component} du projet de démonstration \sl{} (cf. section \ref{subsec:part1handling}). Cette partie avait été volontairement mise de côté, mais elle sert à rendre notre langage ajoutable en tant que plugin à GraalVM, afin de pouvoir l'utiliser dans d'autres langages et pas uniquement en version \textit{standalone}. 

On pourrait ensuite hypothétiquement utiliser le terminal multi-langages de GraalVM pour définir des prédicats en Prolog et les exécuter dans un environnement Java. Mais cela nécessite également que notre implémentation utilise correctement les fonctionnalités de Truffle, ce qui n'est pas le cas actuellement. Il faudrait donc d'abord améliorer l'intégration avec Truffle pour ensuite pouvoir proposer l'interopérabilité.
\subsection{Support du prédicat cut}
Le support du parsing du prédicat peut s'ajouter très facilement. Son comportement, un peu moins... Pour rappel, le cut empêche la remise en question de ce qui le précède, y compris le prédicat qui l'a introduit. Pour l'implémenter, il faudrait donc regarder au moment où on remplace le but courant par le corps de la clause, si elle contient un cut. Ensuite, il faudrait se rappeler de si ce cut a été exécuté ou non (il peut y avoir un échec avant qu'on y arrive). Si ce cut a été exécuté, et qu'il y a un échec après, alors on doit retourner jusqu'au prédicat l'ayant introduit en retournant des échecs même s'il reste d'autres branches possibles. Le prédicat l'ayant introduit doit également retourner un échec. La principale difficulté serait donc de gérer correctement la sauvegarde de qui a introduit le cut, et d'être capable de remonter l'information dans la pile d'appels qu'il faut retourner jusqu'à ce point. 
\subsection{Support d'autres prédicats/de la librairie standard}
Avec l'infrastructure mise en place, l'ajout de la plupart des prédicats simples comme par exemple \texttt{select} est facile. Certains prédicats pourraient cependant poser problème, comme par exemple ceux permettant d'ajouter/enlever dynamiquement des clauses, \texttt{assert} et \texttt{retract}. L'ajout ou la suppression en eux-mêmes ne poseraient pas trop de problèmes, vu qu'il est trivial d'ajouter des éléments à la liste des clauses du programme si l'on possède une référence vers le contexte. Par contre, cela pourrait poser des problèmes avec la fonctionnalité \texttt{redo}, vu que l'arbre de preuve pourrait contenir de nouvelles branches qui n'étaient pas là lors de la précédente descente. Il faudrait donc porter une attention particulière à la correction de la sauvegarde de la descente, ou alors interdire la possibilité de modifier un prédicat en cours d'utilisation...
\end{document}