package ch.heiafr.prolograal.nodes;

import ch.heiafr.prolograal.ProloGraalTypes;
import ch.heiafr.prolograal.runtime.ProloGraalTerm;
import ch.heiafr.prolograal.runtime.ProloGraalVariable;
import com.oracle.truffle.api.dsl.TypeSystemReference;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.instrumentation.GenerateWrapper;
import com.oracle.truffle.api.instrumentation.InstrumentableNode;
import com.oracle.truffle.api.instrumentation.ProbeNode;
import com.oracle.truffle.api.nodes.NodeInfo;

import java.util.Map;

/**
 * Abstract ProloGraal Term Node, being the base class for every ProloGraal Term Nodes.
 * Those nodes are used to handle Prolog terms into builtins,
 * since Truffle children nodes need inherit from com.oracle.truffle.api.nodes.Node.
 * @author Tony Licata
 * @see ProloGraalGenericNode
 */
@TypeSystemReference(ProloGraalTypes.class)
@NodeInfo(shortName = "ProloGraalTermNode")
@GenerateWrapper
public abstract class ProloGraalTermNode extends ProloGraalGenericNode implements InstrumentableNode {

    protected final ProloGraalTerm<?> value;

    public ProloGraalTermNode(ProloGraalTermNode other){
        this.value=other.value;
    }

    public ProloGraalTermNode(ProloGraalTerm<?> value){
        this.value=value;
    }

    /**
     * Return a ProloGraalTerm that would represent the current node.
     * @param frame necessary param to make this method specializable in the Truffle way.
     * @return The term representing this TermNode.
     */
    public abstract ProloGraalTerm executeTerm(VirtualFrame frame);

    public boolean isInstrumentable() {
        return true;
    }

    public InstrumentableNode.WrapperNode createWrapper(ProbeNode probe) {
        // ASTNodeWrapper is generated by @GenerateWrapper
        return new ProloGraalTermNodeWrapper(this,this, probe);
    }

    public abstract ProloGraalTermNode copyTermNode(Map<ProloGraalVariable, ProloGraalVariable> variables);

    public ProloGraalTerm getValue(){
        return value;
    }
}
